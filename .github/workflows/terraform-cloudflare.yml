# Cloudflare Terraform CI/CD
# - development: plan only (PR ou push sur develop)
# - production: apply sur push main
# - Backend: OCI Object Storage (unified with oracle-cloud module)
# - Secrets: CLOUDFLARE_API_TOKEN from GitHub Secrets
name: Cloudflare Infrastructure

on:
  push:
    branches: [main, develop]
    paths:
      - 'terraform/cloudflare/**'
      - '.github/workflows/terraform-cloudflare.yml'
  pull_request:
    branches: [main]
    paths:
      - 'terraform/cloudflare/**'
      - '.github/workflows/terraform-cloudflare.yml'
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'plan'
        type: choice
        options:
          - plan
          - apply
      environment:
        description: 'Target environment'
        required: true
        default: 'development'
        type: choice
        options:
          - development
          - production

concurrency:
  group: terraform-cloudflare
  cancel-in-progress: false

env:
  TF_WORKING_DIR: terraform/cloudflare
  TF_VERSION: '1.14.4'

jobs:
  validate:
    name: Validate
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Format Check
        run: terraform fmt -check -recursive
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Terraform Init
        run: terraform init -backend=false
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Terraform Validate
        run: terraform validate
        working-directory: ${{ env.TF_WORKING_DIR }}

  plan:
    name: Plan
    runs-on: ubuntu-latest
    needs: validate
    if: |
      github.event_name == 'pull_request' ||
      github.ref == 'refs/heads/develop' ||
      github.ref == 'refs/heads/main' ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'plan')
    environment: development
    permissions:
      contents: read
      deployments: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure OCI for Terraform backend
        env:
          OCI_CLI_KEY: ${{ secrets.OCI_CLI_KEY_CONTENT }}
        run: |
          mkdir -p ~/.oci
          printf '%s\n' "$OCI_CLI_KEY" > ~/.oci/oci_api_key.pem
          chmod 600 ~/.oci/oci_api_key.pem
          {
            echo "[DEFAULT]"
            echo "user=${{ secrets.OCI_CLI_USER }}"
            echo "fingerprint=${{ secrets.OCI_CLI_FINGERPRINT }}"
            echo "tenancy=${{ secrets.OCI_CLI_TENANCY }}"
            echo "region=${{ secrets.OCI_CLI_REGION }}"
            echo "key_file=${HOME}/.oci/oci_api_key.pem"
          } > ~/.oci/config

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Inject backend namespace (CI)
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: sed -i.bak "s/YOUR_TENANCY_NAMESPACE/${{ secrets.OCI_OBJECT_STORAGE_NAMESPACE }}/g" main.tf

      - name: Terraform Init
        run: terraform init -reconfigure
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Create tfvars
        run: |
          cat > terraform.tfvars << EOF
          cloudflare_api_token = "${{ secrets.CLOUDFLARE_API_TOKEN }}"
          zone_id = "${{ vars.CLOUDFLARE_ZONE_ID || 'bda8e2196f6b4f1684c6c9c06d996109' }}"
          domain = "smadja.dev"
          # Cloudflare Tunnel (Zero Trust)
          enable_tunnel = ${{ vars.CLOUDFLARE_ENABLE_TUNNEL || 'false' }}
          cloudflare_account_id = "${{ secrets.CLOUDFLARE_ACCOUNT_ID }}"
          tunnel_secret = "${{ secrets.CLOUDFLARE_TUNNEL_SECRET }}"
          EOF
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Force unlock stale Terraform state lock
        uses: ./.github/actions/terraform-force-unlock
        continue-on-error: true
        with:
          working_directory: ${{ env.TF_WORKING_DIR }}
          timeout_minutes: '30'

      - name: Terraform Plan
        run: |
          # Try plan with lock timeout (wait up to 5 minutes for lock to be released)
          if ! terraform plan -no-color -out=tfplan -lock-timeout=5m; then
            # If plan fails due to lock, try to unlock and retry
            echo "::warning::Plan failed, attempting to unlock stale lock..."
            PLAN_OUTPUT=$(terraform plan -no-color -out=tfplan -lock-timeout=0s 2>&1 || true)
            LOCK_ID=$(echo "$PLAN_OUTPUT" | grep -oP 'ID:\s+\K[0-9a-f-]+' | head -1 || echo "")
            if [ -n "$LOCK_ID" ]; then
              echo "::warning::Force unlocking stale lock: $LOCK_ID"
              terraform force-unlock -force "$LOCK_ID" || true
              echo "Retrying plan..."
              terraform plan -no-color -out=tfplan
            else
              echo "::error::Plan failed but no lock ID found"
              exit 1
            fi
          fi
        working-directory: ${{ env.TF_WORKING_DIR }}
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}

      - name: Comment PR with Plan
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const { execSync } = require('child_process');
            const plan = execSync('terraform show -no-color tfplan', {
              cwd: 'terraform/cloudflare',
              encoding: 'utf8',
              maxBuffer: 1024 * 1024 * 10
            });
            const output = `## Cloudflare Terraform Plan (development)\n\n\`\`\`hcl\n${plan.substring(0, 60000)}\n\`\`\`\n\n*Pushed by: @${{ github.actor }}*`;
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            });

  apply:
    name: Apply
    runs-on: ubuntu-latest
    needs: [validate, plan]
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply' && github.event.inputs.environment == 'production')
    environment: production
    permissions:
      contents: read
      deployments: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure OCI for Terraform backend
        env:
          OCI_CLI_KEY: ${{ secrets.OCI_CLI_KEY_CONTENT }}
        run: |
          mkdir -p ~/.oci
          printf '%s\n' "$OCI_CLI_KEY" > ~/.oci/oci_api_key.pem
          chmod 600 ~/.oci/oci_api_key.pem
          {
            echo "[DEFAULT]"
            echo "user=${{ secrets.OCI_CLI_USER }}"
            echo "fingerprint=${{ secrets.OCI_CLI_FINGERPRINT }}"
            echo "tenancy=${{ secrets.OCI_CLI_TENANCY }}"
            echo "region=${{ secrets.OCI_CLI_REGION }}"
            echo "key_file=${HOME}/.oci/oci_api_key.pem"
          } > ~/.oci/config

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Inject backend namespace (CI)
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: sed -i.bak "s/YOUR_TENANCY_NAMESPACE/${{ secrets.OCI_OBJECT_STORAGE_NAMESPACE }}/g" main.tf

      - name: Terraform Init
        run: terraform init -reconfigure
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Create tfvars
        run: |
          cat > terraform.tfvars << EOF
          cloudflare_api_token = "${{ secrets.CLOUDFLARE_API_TOKEN }}"
          zone_id = "${{ vars.CLOUDFLARE_ZONE_ID || 'bda8e2196f6b4f1684c6c9c06d996109' }}"
          domain = "smadja.dev"
          # Cloudflare Tunnel (Zero Trust)
          enable_tunnel = ${{ vars.CLOUDFLARE_ENABLE_TUNNEL || 'false' }}
          cloudflare_account_id = "${{ secrets.CLOUDFLARE_ACCOUNT_ID }}"
          tunnel_secret = "${{ secrets.CLOUDFLARE_TUNNEL_SECRET }}"
          EOF
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Force unlock stale Terraform state lock
        uses: ./.github/actions/terraform-force-unlock
        continue-on-error: true
        with:
          working_directory: ${{ env.TF_WORKING_DIR }}
          timeout_minutes: '30'

      - name: Terraform Apply
        run: |
          # Try apply with lock timeout (wait up to 5 minutes for lock to be released)
          if ! terraform apply -auto-approve -lock-timeout=5m; then
            # If apply fails due to lock, try to unlock and retry
            echo "::warning::Apply failed, attempting to unlock stale lock..."
            APPLY_OUTPUT=$(terraform apply -auto-approve -lock-timeout=0s 2>&1 || true)
            LOCK_ID=$(echo "$APPLY_OUTPUT" | grep -oP 'ID:\s+\K[0-9a-f-]+' | head -1 || echo "")
            if [ -n "$LOCK_ID" ]; then
              echo "::warning::Force unlocking stale lock: $LOCK_ID"
              terraform force-unlock -force "$LOCK_ID" || true
              echo "Retrying apply..."
              terraform apply -auto-approve
            else
              echo "::error::Apply failed but no lock ID found"
              exit 1
            fi
          fi
        working-directory: ${{ env.TF_WORKING_DIR }}
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}

      - name: Terraform Output
        run: terraform output -json
        working-directory: ${{ env.TF_WORKING_DIR }}
