# Authentik Terraform CI/CD
# - development: plan only (PR ou push sur develop)
# - production: apply sur push main
# - Backend: OCI Object Storage (unified with oracle-cloud module)
# - Auth: OAuth2 private_key_jwt (fallback: client_secret temporaire, puis AUTHENTIK_TOKEN pour bootstrap)
name: Authentik Infrastructure

on:
  push:
    branches: [main, develop]
    paths:
      - 'terraform/authentik/**'
      - '.github/workflows/terraform-authentik.yml'
  pull_request:
    branches: [main]
    paths:
      - 'terraform/authentik/**'
      - '.github/workflows/terraform-authentik.yml'
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        default: 'plan'
        type: choice
        options:
          - plan
          - apply
      environment:
        description: 'Target environment'
        required: true
        default: 'development'
        type: choice
        options:
          - development
          - production

concurrency:
  group: terraform-authentik
  cancel-in-progress: false

env:
  TF_WORKING_DIR: terraform/authentik
  TF_VERSION: '1.14.4'

jobs:
  validate:
    name: Validate
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Format Check
        run: terraform fmt -check -recursive
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Terraform Init
        run: terraform init -backend=false
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Terraform Validate
        run: terraform validate
        working-directory: ${{ env.TF_WORKING_DIR }}
        env:
          AUTHENTIK_URL: "https://auth.smadja.dev"
          AUTHENTIK_TOKEN: "dummy-token-for-validation"

  plan:
    name: Plan
    runs-on: ubuntu-latest
    needs: validate
    if: |
      github.event_name == 'pull_request' ||
      github.ref == 'refs/heads/develop' ||
      github.ref == 'refs/heads/main' ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'plan')
    environment: development
    permissions:
      contents: read
      deployments: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure OCI for Terraform backend
        env:
          OCI_CLI_KEY: ${{ secrets.OCI_CLI_KEY_CONTENT }}
        run: |
          mkdir -p ~/.oci
          printf '%s\n' "$OCI_CLI_KEY" > ~/.oci/oci_api_key.pem
          chmod 600 ~/.oci/oci_api_key.pem
          {
            echo "[DEFAULT]"
            echo "user=${{ secrets.OCI_CLI_USER }}"
            echo "fingerprint=${{ secrets.OCI_CLI_FINGERPRINT }}"
            echo "tenancy=${{ secrets.OCI_CLI_TENANCY }}"
            echo "region=${{ secrets.OCI_CLI_REGION }}"
            echo "key_file=${HOME}/.oci/oci_api_key.pem"
          } > ~/.oci/config

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Inject backend namespace (CI)
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          if [ -f backend.tf ]; then
            # Replace any namespace value (including YOUR_TENANCY_NAMESPACE placeholder or existing value)
            # This ensures CI always uses the secret namespace, allowing shared state between local and CI
            sed -i.bak "s/namespace = \"[^\"]*\"/namespace = \"${{ secrets.OCI_OBJECT_STORAGE_NAMESPACE }}\"/g" backend.tf
          fi

      - name: Fetch Authentik secrets from OCI Vault
        id: vault-secrets
        uses: ./.github/actions/oci-vault-secrets
        with:
          secrets: 'authentik_token,authentik_oauth2_client_id,authentik_oauth2_client_secret,authentik_private_key_pem'
          oci_cli_key_content: ${{ secrets.OCI_CLI_KEY_CONTENT }}
          oci_cli_user: ${{ secrets.OCI_CLI_USER }}
          oci_cli_fingerprint: ${{ secrets.OCI_CLI_FINGERPRINT }}
          oci_cli_tenancy: ${{ secrets.OCI_CLI_TENANCY }}
          oci_cli_region: ${{ secrets.OCI_CLI_REGION }}
          oci_domain_url: ${{ secrets.OCI_DOMAIN_URL }}
          oci_client_id: ${{ secrets.OCI_OIDC_CLIENT_ID }}
          oci_client_secret: ${{ secrets.OCI_OIDC_CLIENT_SECRET }}
        continue-on-error: true

      - name: Terraform Init
        run: terraform init -reconfigure
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Authenticate with Authentik OAuth2 (private_key_jwt)
        id: authentik_oauth2
        uses: ./.github/actions/authentik-private-key-jwt-auth
        continue-on-error: true
        with:
          client_id: ${{ steps.vault-secrets.outputs.authentik_oauth2_client_id || 'ci-automation' }}
          private_key_pem: ${{ steps.vault-secrets.outputs.authentik_private_key_pem }}
          issuer_url: 'https://auth.smadja.dev/application/o/ci-automation/'
          scope: "goauthentik.io/api"

      - name: Fallback to client_secret if private_key_jwt fails
        if: steps.authentik_oauth2.outputs.token_source != 'private_key_jwt'
        id: authentik_oauth2_fallback
        uses: ./.github/actions/authentik-oauth2-auth
        continue-on-error: true
        with:
          client_id: ${{ steps.vault-secrets.outputs.authentik_oauth2_client_id }}
          client_secret: ${{ steps.vault-secrets.outputs.authentik_oauth2_client_secret }}
          scope: "goauthentik.io/api"

      - name: Terraform Plan
        run: terraform plan -no-color -out=tfplan
        working-directory: ${{ env.TF_WORKING_DIR }}
        env:
          AUTHENTIK_URL: ${{ secrets.AUTHENTIK_URL || 'https://auth.smadja.dev' }}
          AUTHENTIK_TOKEN: >-
            ${{ steps.authentik_oauth2.outputs.token_source == 'private_key_jwt' && steps.authentik_oauth2.outputs.access_token ||
            (steps.authentik_oauth2_fallback.outputs.token_source == 'oauth2' && steps.authentik_oauth2_fallback.outputs.access_token) ||
            steps.vault-secrets.outputs.authentik_token || secrets.AUTHENTIK_TOKEN }}

      - name: Comment PR with Plan
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const { execSync } = require('child_process');
            const plan = execSync('terraform show -no-color tfplan', {
              cwd: 'terraform/authentik',
              encoding: 'utf8',
              maxBuffer: 1024 * 1024 * 10
            });
            const output = `## Authentik Terraform Plan (development)\n\n\`\`\`hcl\n${plan.substring(0, 60000)}\n\`\`\`\n\n*Pushed by: @${{ github.actor }}*`;
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            });

  apply:
    name: Apply
    runs-on: ubuntu-latest
    needs: [validate, plan]
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply' && github.event.inputs.environment == 'production')
    environment: production
    permissions:
      contents: read
      deployments: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure OCI for Terraform backend
        env:
          OCI_CLI_KEY: ${{ secrets.OCI_CLI_KEY_CONTENT }}
        run: |
          mkdir -p ~/.oci
          printf '%s\n' "$OCI_CLI_KEY" > ~/.oci/oci_api_key.pem
          chmod 600 ~/.oci/oci_api_key.pem
          {
            echo "[DEFAULT]"
            echo "user=${{ secrets.OCI_CLI_USER }}"
            echo "fingerprint=${{ secrets.OCI_CLI_FINGERPRINT }}"
            echo "tenancy=${{ secrets.OCI_CLI_TENANCY }}"
            echo "region=${{ secrets.OCI_CLI_REGION }}"
            echo "key_file=${HOME}/.oci/oci_api_key.pem"
          } > ~/.oci/config

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Inject backend namespace (CI)
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: |
          if [ -f backend.tf ]; then
            # Replace any namespace value (including YOUR_TENANCY_NAMESPACE placeholder or existing value)
            # This ensures CI always uses the secret namespace, allowing shared state between local and CI
            sed -i.bak "s/namespace = \"[^\"]*\"/namespace = \"${{ secrets.OCI_OBJECT_STORAGE_NAMESPACE }}\"/g" backend.tf
          fi

      - name: Fetch Authentik secrets from OCI Vault
        id: vault-secrets
        uses: ./.github/actions/oci-vault-secrets
        with:
          secrets: 'authentik_token,authentik_oauth2_client_id,authentik_oauth2_client_secret,authentik_private_key_pem'
          oci_cli_key_content: ${{ secrets.OCI_CLI_KEY_CONTENT }}
          oci_cli_user: ${{ secrets.OCI_CLI_USER }}
          oci_cli_fingerprint: ${{ secrets.OCI_CLI_FINGERPRINT }}
          oci_cli_tenancy: ${{ secrets.OCI_CLI_TENANCY }}
          oci_cli_region: ${{ secrets.OCI_CLI_REGION }}
          oci_domain_url: ${{ secrets.OCI_DOMAIN_URL }}
          oci_client_id: ${{ secrets.OCI_OIDC_CLIENT_ID }}
          oci_client_secret: ${{ secrets.OCI_OIDC_CLIENT_SECRET }}
        continue-on-error: true

      - name: Authenticate with Authentik OAuth2 (private_key_jwt)
        id: authentik_oauth2
        uses: ./.github/actions/authentik-private-key-jwt-auth
        continue-on-error: true
        with:
          client_id: ${{ steps.vault-secrets.outputs.authentik_oauth2_client_id || 'ci-automation' }}
          private_key_pem: ${{ steps.vault-secrets.outputs.authentik_private_key_pem }}
          issuer_url: 'https://auth.smadja.dev/application/o/ci-automation/'
          scope: "goauthentik.io/api"

      - name: Fallback to client_secret if private_key_jwt fails
        if: steps.authentik_oauth2.outputs.token_source != 'private_key_jwt'
        id: authentik_oauth2_fallback
        uses: ./.github/actions/authentik-oauth2-auth
        continue-on-error: true
        with:
          client_id: ${{ steps.vault-secrets.outputs.authentik_oauth2_client_id }}
          client_secret: ${{ steps.vault-secrets.outputs.authentik_oauth2_client_secret }}
          scope: "goauthentik.io/api"

      - name: Terraform Init
        run: terraform init -reconfigure
        working-directory: ${{ env.TF_WORKING_DIR }}

      - name: Import outpost (if needed, first time only)
        continue-on-error: true
        run: |
          # Check if outpost resource exists in state
          if terraform state list | grep -q "authentik_outpost.embedded"; then
            echo "Outpost already imported, skipping"
          else
            echo "Outpost not in state. To import manually:"
            echo "1. Get outpost UUID from Authentik UI: Applications → Outposts → 'authentik Embedded Outpost'"
            echo "2. Run: terraform import authentik_outpost.embedded <UUID>"
            echo "3. Re-run this workflow"
            # Don't fail - user can import manually or skip if outpost doesn't exist yet
          fi
        working-directory: ${{ env.TF_WORKING_DIR }}
        env:
          AUTHENTIK_URL: ${{ secrets.AUTHENTIK_URL || 'https://auth.smadja.dev' }}
          AUTHENTIK_TOKEN: >-
            ${{ steps.authentik_oauth2.outputs.token_source == 'private_key_jwt' && steps.authentik_oauth2.outputs.access_token ||
            (steps.authentik_oauth2_fallback.outputs.token_source == 'oauth2' && steps.authentik_oauth2_fallback.outputs.access_token) ||
            steps.vault-secrets.outputs.authentik_token || secrets.AUTHENTIK_TOKEN }}

      - name: Terraform Apply
        run: terraform apply -auto-approve
        working-directory: ${{ env.TF_WORKING_DIR }}
        env:
          AUTHENTIK_URL: ${{ secrets.AUTHENTIK_URL || 'https://auth.smadja.dev' }}
          AUTHENTIK_TOKEN: >-
            ${{ steps.authentik_oauth2.outputs.token_source == 'private_key_jwt' && steps.authentik_oauth2.outputs.access_token ||
            (steps.authentik_oauth2_fallback.outputs.token_source == 'oauth2' && steps.authentik_oauth2_fallback.outputs.access_token) ||
            steps.vault-secrets.outputs.authentik_token || secrets.AUTHENTIK_TOKEN }}

      - name: Terraform Output and Auto-update OCI Vault Secrets
        id: terraform_output
        run: |
          echo "::notice::Terraform outputs:"
          terraform output -json | jq -r 'to_entries[] | "\(.key)=\(.value.value // .value)"' || true

          # CI Automation OAuth2 outputs (generic provider for all CI/CD services)
          CI_CLIENT_ID=$(terraform output -raw ci_automation_oauth2_client_id 2>/dev/null || echo "")
          CI_CLIENT_SECRET=$(terraform output -raw ci_automation_oauth2_client_secret 2>/dev/null || echo "")
          CI_ISSUER_URL=$(terraform output -raw ci_automation_oauth2_issuer_url 2>/dev/null || echo "")

          if [ -n "$CI_CLIENT_ID" ]; then
            echo "ci_client_id=$CI_CLIENT_ID" >> $GITHUB_OUTPUT
          fi
          if [ -n "$CI_CLIENT_SECRET" ]; then
            echo "ci_client_secret=$CI_CLIENT_SECRET" >> $GITHUB_OUTPUT
          fi
          if [ -n "$CI_ISSUER_URL" ]; then
            echo "ci_issuer_url=$CI_ISSUER_URL" >> $GITHUB_OUTPUT
          fi
        working-directory: ${{ env.TF_WORKING_DIR }}
        env:
          AUTHENTIK_URL: ${{ secrets.AUTHENTIK_URL || 'https://auth.smadja.dev' }}
          AUTHENTIK_TOKEN: ${{ steps.vault-secrets.outputs.authentik_token || secrets.AUTHENTIK_TOKEN }}

      - name: Auto-update OCI Vault secrets (client_id)
        if: steps.terraform_output.outputs.ci_client_id != ''
        uses: ./.github/actions/oci-vault-update-secret
        continue-on-error: true
        with:
          secret_name: 'homelab-authentik-oauth2-client-id'
          secret_value: ${{ steps.terraform_output.outputs.ci_client_id }}
          oci_cli_key_content: ${{ secrets.OCI_CLI_KEY_CONTENT }}
          oci_cli_user: ${{ secrets.OCI_CLI_USER }}
          oci_cli_fingerprint: ${{ secrets.OCI_CLI_FINGERPRINT }}
          oci_cli_tenancy: ${{ secrets.OCI_CLI_TENANCY }}
          oci_cli_region: ${{ secrets.OCI_CLI_REGION }}
          oci_domain_url: ${{ secrets.OCI_DOMAIN_URL }}
          oci_client_id: ${{ secrets.OCI_OIDC_CLIENT_ID }}
          oci_client_secret: ${{ secrets.OCI_OIDC_CLIENT_SECRET }}

      - name: Auto-update OCI Vault secrets (client_secret)
        if: steps.terraform_output.outputs.ci_client_secret != ''
        uses: ./.github/actions/oci-vault-update-secret
        continue-on-error: true
        with:
          secret_name: 'homelab-authentik-oauth2-client-secret'
          secret_value: ${{ steps.terraform_output.outputs.ci_client_secret }}
          oci_cli_key_content: ${{ secrets.OCI_CLI_KEY_CONTENT }}
          oci_cli_user: ${{ secrets.OCI_CLI_USER }}
          oci_cli_fingerprint: ${{ secrets.OCI_CLI_FINGERPRINT }}
          oci_cli_tenancy: ${{ secrets.OCI_CLI_TENANCY }}
          oci_cli_region: ${{ secrets.OCI_CLI_REGION }}
          oci_domain_url: ${{ secrets.OCI_DOMAIN_URL }}
          oci_client_id: ${{ secrets.OCI_OIDC_CLIENT_ID }}
          oci_client_secret: ${{ secrets.OCI_OIDC_CLIENT_SECRET }}

      - name: Post-apply - Enable Client credentials grant type
        continue-on-error: true
        run: |
          echo "::notice::After terraform apply, enable 'Client credentials' grant type in Authentik UI:"
          echo "Applications → Providers → ci-automation → Edit → Grant types → Client credentials → Update"
          echo ""
          echo "This single provider is used by all CI/CD workflows (Omni GitOps, Terraform Authentik, ArgoCD, etc.)."
          echo "This step cannot be automated via Terraform provider (not exposed in API)."
        working-directory: ${{ env.TF_WORKING_DIR }}
