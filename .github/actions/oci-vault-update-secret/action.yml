# Composite action to update an OCI Vault secret
# Usage in workflow:
#   - uses: ./.github/actions/oci-vault-update-secret
#     with:
#       secret_name: 'homelab-authentik-oauth2-client-id'
#       secret_value: ${{ steps.terraform.outputs.ci_client_id }}
#       oci_cli_key_content: ${{ secrets.OCI_CLI_KEY_CONTENT }}
#       ...
#
# Requires OCI API key secrets already configured in GitHub.
name: 'Update OCI Vault Secret'
description: 'Updates an existing OCI Vault secret with new content'

inputs:
  secret_name:
    description: 'Name of the secret in OCI Vault (e.g., homelab-authentik-oauth2-client-id)'
    required: true
  secret_value:
    description: 'New secret value to store (will be base64 encoded)'
    required: true
  oci_cli_key_content:
    description: 'OCI CLI API Key Content (PEM)'
    required: true
  oci_cli_user:
    description: 'OCI CLI User OCID'
    required: true
  oci_cli_fingerprint:
    description: 'OCI CLI Fingerprint'
    required: true
  oci_cli_tenancy:
    description: 'OCI CLI Tenancy OCID'
    required: true
  oci_cli_region:
    description: 'OCI CLI Region'
    required: true
    default: 'eu-paris-1'
  oci_domain_url:
    description: 'OCI Identity Domain URL (for OIDC)'
    required: false
    default: ''
  oci_client_id:
    description: 'OCI OIDC OAuth Client ID'
    required: false
    default: ''
  oci_client_secret:
    description: 'OCI OIDC OAuth Client Secret'
    required: false
    default: ''

outputs:
  secret_ocid:
    description: 'OCID of the updated secret'
    value: ${{ steps.update.outputs.secret_ocid }}
  updated:
    description: 'Whether the secret was updated (true) or created (false)'
    value: ${{ steps.update.outputs.updated }}

runs:
  using: 'composite'
  steps:
    - name: Install OCI CLI
      shell: bash
      run: |
        if ! command -v oci &> /dev/null; then
          echo "Installing OCI CLI..."
          curl -L https://raw.githubusercontent.com/oracle/oci-cli/master/scripts/install/install.sh | bash -s -- --accept-all-defaults
          echo "$HOME/bin" >> $GITHUB_PATH
        fi

    - name: Authenticate to OCI using OIDC
      id: oci-auth
      uses: ./.github/actions/oci-oidc-auth
      with:
        oci_tenancy_ocid: ${{ inputs.oci_cli_tenancy }}
        oci_user_ocid: ${{ inputs.oci_cli_user }}
        oci_fingerprint: ${{ inputs.oci_cli_fingerprint }}
        oci_region: ${{ inputs.oci_cli_region }}
        oci_api_key_content: ${{ inputs.oci_cli_key_content }}
        oci_domain_url: ${{ inputs.oci_domain_url }}
        oci_client_id: ${{ inputs.oci_client_id }}
        oci_client_secret: ${{ inputs.oci_client_secret }}

    - name: Configure OCI Authentication
      shell: bash
      env:
        OCI_SESSION_TOKEN: ${{ steps.oci-auth.outputs.oci_session_token }}
        OCI_SESSION_KEY: ${{ steps.oci-auth.outputs.oci_session_key }}
        AUTH_METHOD: ${{ steps.oci-auth.outputs.auth_method }}
      run: |
        mkdir -p ~/.oci

        if [[ "$AUTH_METHOD" == "oidc" && -n "$OCI_SESSION_TOKEN" ]]; then
          echo "Using OIDC authentication (UPST) for Vault access"
          printf '%s\n' "$OCI_SESSION_TOKEN" > ~/.oci/session_token
          printf '%s\n' "$OCI_SESSION_KEY" > ~/.oci/session_key.pem
          chmod 600 ~/.oci/session_key.pem
          {
            echo "[DEFAULT]"
            echo "auth=security_token"
            echo "user=${{ inputs.oci_cli_user }}"
            echo "fingerprint=${{ inputs.oci_cli_fingerprint }}"
            echo "tenancy=${{ inputs.oci_cli_tenancy }}"
            echo "region=${{ inputs.oci_cli_region }}"
            echo "security_token_file=${HOME}/.oci/session_token"
            echo "key_file=${HOME}/.oci/session_key.pem"
          } > ~/.oci/config
        else
          echo "Using API key authentication (fallback) for Vault access"
          printf '%s\n' "${{ inputs.oci_cli_key_content }}" > ~/.oci/oci_api_key.pem
          chmod 600 ~/.oci/oci_api_key.pem
          {
            echo "[DEFAULT]"
            echo "user=${{ inputs.oci_cli_user }}"
            echo "fingerprint=${{ inputs.oci_cli_fingerprint }}"
            echo "tenancy=${{ inputs.oci_cli_tenancy }}"
            echo "region=${{ inputs.oci_cli_region }}"
            echo "key_file=${HOME}/.oci/oci_api_key.pem"
          } > ~/.oci/config
        fi

    - name: Get Vault and Key OCIDs
      id: vault-config
      shell: bash
      env:
        COMPARTMENT_ID: ${{ inputs.oci_cli_tenancy }}
      run: |
        # Try to get from OCI API first (more reliable in CI)
        echo "Fetching Vault and Key OCIDs from OCI API..."

        # Get vault by name (try multiple name variations)
        VAULT_ID=$(oci kms vault list \
          --compartment-id "$COMPARTMENT_ID" \
          --query 'data[?display_name==`homelab-secrets` || display_name==`homelab-secrets-vault`].id' \
          --raw-output 2>/dev/null | head -1 | tr -d '"' || echo "")

        if [[ -z "$VAULT_ID" ]]; then
          echo "::warning::Vault 'homelab-secrets' not found, trying alternative methods..."
          # Try to get any vault in compartment
          VAULT_ID=$(oci kms vault list \
            --compartment-id "$COMPARTMENT_ID" \
            --query 'data[0].id' \
            --raw-output 2>/dev/null | head -1 | tr -d '"' || echo "")
        fi

        if [[ -n "$VAULT_ID" ]]; then
          # Get vault details to retrieve management endpoint
          VAULT_MGMT_ENDPOINT=$(oci kms vault get \
            --vault-id "$VAULT_ID" \
            --query 'data."management-endpoint"' \
            --raw-output 2>/dev/null | tr -d '"' || echo "")

          if [[ -n "$VAULT_MGMT_ENDPOINT" ]]; then
            echo "Found vault management endpoint: ${VAULT_MGMT_ENDPOINT:0:50}..."
            # Get key from vault using management endpoint
            KEY_ID=$(oci kms management key list \
              --compartment-id "$COMPARTMENT_ID" \
              --endpoint "$VAULT_MGMT_ENDPOINT" \
              --query 'data[?display_name==`homelab-secrets-master-key` || display_name==`homelab-secrets-key`].id' \
              --raw-output 2>/dev/null | head -1 | tr -d '"' || echo "")

            # If not found by name, get the first key
            if [[ -z "$KEY_ID" ]]; then
              KEY_ID=$(oci kms management key list \
                --compartment-id "$COMPARTMENT_ID" \
                --endpoint "$VAULT_MGMT_ENDPOINT" \
                --query 'data[0].id' \
                --raw-output 2>/dev/null | head -1 | tr -d '"' || echo "")
            fi
          else
            echo "::warning::Could not retrieve vault management endpoint"
          fi
        fi

        # Fallback: try Terraform state if API failed
        if [[ -z "$VAULT_ID" || -z "$KEY_ID" ]]; then
          echo "::notice::Trying Terraform state as fallback..."
          cd terraform/oracle-cloud 2>/dev/null || cd ../../terraform/oracle-cloud 2>/dev/null || true

          if [[ -f terraform.tfstate ]] || command -v terraform &> /dev/null; then
            VAULT_ID=$(terraform output -json vault_secrets 2>/dev/null | jq -r '.vault_id // empty' || echo "")
            KEY_ID=$(terraform state show oci_kms_key.homelab_secrets_key 2>/dev/null | grep '^\s*id\s*=' | head -1 | awk -F'"' '{print $2}' || echo "")
          fi
        fi

        if [[ -z "$VAULT_ID" || -z "$KEY_ID" ]]; then
          echo "::error::Could not determine Vault ID or Key ID."
          echo "::error::Make sure the vault 'homelab-secrets' exists in OCI or Terraform state is accessible."
          exit 1
        fi

        echo "vault_id=$VAULT_ID" >> $GITHUB_OUTPUT
        echo "key_id=$KEY_ID" >> $GITHUB_OUTPUT
        echo "compartment_id=$COMPARTMENT_ID" >> $GITHUB_OUTPUT
        echo "::notice::Using Vault: ${VAULT_ID:0:50}..."
        echo "::notice::Using Key: ${KEY_ID:0:50}..."

    - name: Update OCI Vault Secret
      id: update
      shell: bash
      env:
        SECRET_NAME: ${{ inputs.secret_name }}
        SECRET_VALUE: ${{ inputs.secret_value }}
        VAULT_ID: ${{ steps.vault-config.outputs.vault_id }}
        KEY_ID: ${{ steps.vault-config.outputs.key_id }}
        COMPARTMENT_ID: ${{ steps.vault-config.outputs.compartment_id }}
      run: |
        if [[ -z "$SECRET_VALUE" ]]; then
          echo "::warning::Secret value is empty, skipping update"
          exit 0
        fi

        # Mask the secret value in logs
        echo "::add-mask::$SECRET_VALUE"

        # Check if secret exists
        EXISTING_SECRET_OCID=$(oci vault secret list \
          --compartment-id "$COMPARTMENT_ID" \
          --name "$SECRET_NAME" \
          --lifecycle-state ACTIVE \
          --query 'data[0].id' \
          --raw-output 2>/dev/null || echo "")

        # Base64 encode the secret value
        SECRET_B64=$(echo -n "$SECRET_VALUE" | base64 -w0)

        if [[ -n "$EXISTING_SECRET_OCID" && "$EXISTING_SECRET_OCID" != "null" ]]; then
          echo "Updating existing secret: $SECRET_NAME"
          oci vault secret update-base64 \
            --secret-id "$EXISTING_SECRET_OCID" \
            --secret-content-content "$SECRET_B64" \
            --force
          echo "secret_ocid=$EXISTING_SECRET_OCID" >> $GITHUB_OUTPUT
          echo "updated=true" >> $GITHUB_OUTPUT
          echo "::notice::✓ Secret updated: $SECRET_NAME"
        else
          echo "Creating new secret: $SECRET_NAME"
          RESULT=$(oci vault secret create-base64 \
            --compartment-id "$COMPARTMENT_ID" \
            --vault-id "$VAULT_ID" \
            --key-id "$KEY_ID" \
            --secret-name "$SECRET_NAME" \
            --secret-content-content "$SECRET_B64" \
            --query 'data.id' \
            --raw-output)
          echo "secret_ocid=$RESULT" >> $GITHUB_OUTPUT
          echo "updated=false" >> $GITHUB_OUTPUT
          echo "::notice::✓ Secret created: $SECRET_NAME"
        fi
