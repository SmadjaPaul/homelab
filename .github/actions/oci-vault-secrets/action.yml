# Composite action to fetch secrets from OCI Vault
# Usage in workflow:
#   - uses: ./.github/actions/oci-vault-secrets
#     id: secrets
#     with:
#       secrets: 'cloudflare_api_token'
#       oci_cli_key_content: ${{ secrets.OCI_CLI_KEY_CONTENT }}
#       ...
#   - run: echo "Token is ${{ steps.secrets.outputs.cloudflare_api_token }}"
#
# Requires OCI API key secrets already configured in GitHub.
name: 'Fetch OCI Vault Secrets'
description: 'Retrieves secrets from OCI Vault and exposes them as outputs'

inputs:
  secrets:
    description: 'Comma-separated list of secrets to fetch (e.g., cloudflare_api_token)'
    required: true
  oci_cli_key_content:
    description: 'OCI CLI API Key Content (PEM)'
    required: true
  oci_cli_user:
    description: 'OCI CLI User OCID'
    required: true
  oci_cli_fingerprint:
    description: 'OCI CLI Fingerprint'
    required: true
  oci_cli_tenancy:
    description: 'OCI CLI Tenancy OCID'
    required: true
  oci_cli_region:
    description: 'OCI CLI Region'
    required: true
    default: 'eu-paris-1'

outputs:
  cloudflare_api_token:
    description: 'Cloudflare API Token'
    value: ${{ steps.fetch.outputs.cloudflare_api_token }}
  tfstate_dev_token:
    description: 'TFstate.dev / GitHub PAT'
    value: ${{ steps.fetch.outputs.tfstate_dev_token }}
  omni_db_user:
    description: 'Omni DB User'
    value: ${{ steps.fetch.outputs.omni_db_user }}
  omni_db_password:
    description: 'Omni DB Password'
    value: ${{ steps.fetch.outputs.omni_db_password }}
  omni_db_name:
    description: 'Omni DB Name'
    value: ${{ steps.fetch.outputs.omni_db_name }}
  oci_mgmt_ssh_private_key:
    description: 'OCI Management SSH Private Key'
    value: ${{ steps.fetch.outputs.oci_mgmt_ssh_private_key }}

runs:
  using: 'composite'
  steps:
    - name: Install OCI CLI
      shell: bash
      run: |
        if ! command -v oci &> /dev/null; then
          echo "Installing OCI CLI..."
          curl -L https://raw.githubusercontent.com/oracle/oci-cli/master/scripts/install/install.sh | bash -s -- --accept-all-defaults
          echo "$HOME/bin" >> $GITHUB_PATH
        fi

    - name: Authenticate to OCI using OIDC
      id: oci-auth
      uses: ./.github/actions/oci-oidc-auth
      with:
        oci_tenancy_ocid: ${{ inputs.oci_cli_tenancy }}
        oci_user_ocid: ${{ inputs.oci_cli_user }}
        oci_fingerprint: ${{ inputs.oci_cli_fingerprint }}
        oci_region: ${{ inputs.oci_cli_region }}
        oci_api_key_content: ${{ inputs.oci_cli_key_content }}

    - name: Configure OCI Authentication
      shell: bash
      env:
        OCI_SESSION_TOKEN: ${{ steps.oci-auth.outputs.oci_session_token }}
        OCI_SESSION_KEY: ${{ steps.oci-auth.outputs.oci_session_key }}
        AUTH_METHOD: ${{ steps.oci-auth.outputs.auth_method }}
      run: |
        mkdir -p ~/.oci

        if [[ "$AUTH_METHOD" == "oidc" && -n "$OCI_SESSION_TOKEN" ]]; then
          echo "Using OIDC authentication (UPST) for Vault access"
          printf '%s\n' "$OCI_SESSION_TOKEN" > ~/.oci/session_token
          printf '%s\n' "$OCI_SESSION_KEY" > ~/.oci/session_key.pem
          chmod 600 ~/.oci/session_key.pem
          {
            echo "[DEFAULT]"
            echo "auth=security_token"
            echo "user=${{ inputs.oci_cli_user }}"
            echo "fingerprint=${{ inputs.oci_cli_fingerprint }}"
            echo "tenancy=${{ inputs.oci_cli_tenancy }}"
            echo "region=${{ inputs.oci_cli_region }}"
            echo "security_token_file=${HOME}/.oci/session_token"
            echo "key_file=${HOME}/.oci/session_key.pem"
          } > ~/.oci/config
        else
          echo "Using API key authentication (fallback) for Vault access"
          printf '%s\n' "${{ inputs.oci_cli_key_content }}" > ~/.oci/oci_api_key.pem
          chmod 600 ~/.oci/oci_api_key.pem
          {
            echo "[DEFAULT]"
            echo "user=${{ inputs.oci_cli_user }}"
            echo "fingerprint=${{ inputs.oci_cli_fingerprint }}"
            echo "tenancy=${{ inputs.oci_cli_tenancy }}"
            echo "region=${{ inputs.oci_cli_region }}"
            echo "key_file=${HOME}/.oci/oci_api_key.pem"
          } > ~/.oci/config
        fi

    - name: Fetch secrets from OCI Vault
      id: fetch
      shell: bash
      run: |
        # Secret name to OCID mapping (from Terraform)
        # These are the secret names created by terraform/oracle-cloud/vault-secrets.tf
        declare -A SECRET_NAMES=(
          ["cloudflare_api_token"]="homelab-cloudflare-api-token"
          ["tfstate_dev_token"]="homelab-tfstate-dev-token"
          ["omni_db_user"]="homelab-omni-db-user"
          ["omni_db_password"]="homelab-omni-db-password"
          ["omni_db_name"]="homelab-omni-db-name"
          ["oci_mgmt_ssh_private_key"]="homelab-oci-mgmt-ssh-private-key"
        )

        # Compartment ID (tenancy root)
        COMPARTMENT_ID="${{ inputs.oci_cli_tenancy }}"

        # Parse requested secrets
        IFS=',' read -ra REQUESTED <<< "${{ inputs.secrets }}"

        for secret_key in "${REQUESTED[@]}"; do
          secret_key=$(echo "$secret_key" | xargs)  # trim whitespace
          secret_name="${SECRET_NAMES[$secret_key]}"

          if [[ -z "$secret_name" ]]; then
            echo "::warning::Unknown secret key: $secret_key"
            continue
          fi

          echo "Fetching $secret_key ($secret_name)..."

          # Get secret OCID by name
          SECRET_OCID=$(oci vault secret list \
            --compartment-id "$COMPARTMENT_ID" \
            --name "$secret_name" \
            --lifecycle-state ACTIVE \
            --query 'data[0].id' \
            --raw-output 2>/dev/null || true)

          if [[ -z "$SECRET_OCID" || "$SECRET_OCID" == "null" ]]; then
            echo "::warning::Secret not found: $secret_name"
            continue
          fi

          # Get latest secret bundle (content)
          SECRET_VALUE=$(oci secrets secret-bundle get \
            --secret-id "$SECRET_OCID" \
            --stage CURRENT \
            --query 'data."secret-bundle-content".content' \
            --raw-output 2>/dev/null || true)

          if [[ -z "$SECRET_VALUE" || "$SECRET_VALUE" == "null" ]]; then
            echo "::warning::Could not retrieve content for: $secret_name"
            continue
          fi

          # Decode base64
          DECODED=$(echo "$SECRET_VALUE" | base64 -d)

          if [[ -z "$DECODED" ]]; then
            echo "::error::Secret $secret_name is empty after decoding"
            exit 1
          fi

          # Mask the secret in logs
          echo "::add-mask::$DECODED"

          # Check if secret contains newlines (multiline secret like SSH keys)
          if echo "$DECODED" | grep -q $'\n'; then
            # Multiline secret: use heredoc format
            {
              echo "${secret_key}<<EOF_${secret_key}"
              echo "$DECODED"
              echo "EOF_${secret_key}"
            } >> "$GITHUB_OUTPUT"
          else
            # Single-line secret: trim whitespace and use simple format
            DECODED_TRIMMED=$(echo "$DECODED" | tr -d '\n\r' | xargs)

            # Special validation for Cloudflare API token (must be exactly 40 chars)
            if [[ "$secret_key" == "cloudflare_api_token" ]]; then
              if [[ ${#DECODED_TRIMMED} -ne 40 ]]; then
                echo "::error::Cloudflare API token must be exactly 40 characters, got ${#DECODED_TRIMMED}"
                echo "::error::Token value (first 10 chars): ${DECODED_TRIMMED:0:10}..."
                exit 1
              fi
              # Validate format (only alphanumeric, hyphens, underscores)
              if ! echo "$DECODED_TRIMMED" | grep -qE '^[a-zA-Z0-9_-]{40}$'; then
                echo "::error::Cloudflare API token contains invalid characters"
                exit 1
              fi
            fi

            echo "${secret_key}=$DECODED_TRIMMED" >> "$GITHUB_OUTPUT"
          fi

          echo "âœ“ $secret_key fetched successfully"
        done
